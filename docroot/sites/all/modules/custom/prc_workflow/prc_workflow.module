<?php

/**
 * @file Hooks and configuration pertaining to the editing workflow of the PRC site.
 */

/**
 * Implements hook_permission
 *
 * @return array
 */
function prc_workflow_permission(){
  return array(
    'request approval of prc content' => array(
      'title' => t('Request Approval of PRC content'),
      'description' => t('Request that content be approved and published through the PRC workflow.'),
    ),
    'approve prc content' => array(
      'title' => t('Publish PRC content'),
      'description' => t('Approve and publish content managed through the PRC workflow.'),
    ),
    'deny prc content' => array(
      'title' => t('Deny PRC content'),
      'description' => t('Deny publishing of content managed through the PRC workflow.')
    ),
    'unpublish prc content' => array(
      'title' => t('Unpublish PRC content'),
      'description' => t('Move content managed through the PRC workflow from published back to draft'),
    ),
  );
}


/**
 * Implements hook_menu_alter()
 */
function prc_workflow_menu_alter(&$menu){
  $menu['node/%node/edit']['access callback'] = 'prc_workflow_access';
  $menu['node/%node/revisions/%/workflow']['access callback'] = 'prc_workflow_events_revision_access';
}

function prc_workflow_access($op, $node){
  if(node_access($op, $node)){
    $state_flow = state_flow_load_state_machine($node);

    //Block access to editing for contributors when under review
    if($op == 'update' && $state_flow->get_current_state() === 'ready_for_review') {
      return user_access('approve prc content');
    }else{
      return TRUE;
    }
  }else {
    return FALSE;
  }
}

/**
 * Menu access callback for the node revision workflow transition page.
 */
function prc_workflow_events_revision_access($node, $event_name = NULL) {
  $machine = state_flow_load_state_machine($node);

  //if there is an event name base access on that, otherwise pass to state flow
  if($event_name) {
    $event = $machine->get_event($event_name);

    return $event->validate();
  }else{
    return !empty($event_name) ? state_flow_access($node, $event_name) : state_flow_menu_node_access($node);
  }
}

/**
 * Implements hook_ctools_plugin_directory()
 *
 * @param $owner
 * @param $plugin_type
 * @return string
 */
function prc_workflow_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'ctools') {
    return "plugins/$plugin_type";
  }
}

/**
 * Implements hook_state_flow_plugins()
 */
function prc_workflow_state_flow_plugins(){
  $info = array();

  $info['prc_workflow'] = array(
    'handler' => array(
      'parent' => 'state_flow',
      'class' => 'prcWorkflow',
      'file' => 'prcWorkflow.inc',
      'path' => drupal_get_path('module', 'prc_workflow').'/plugins',
    )
  );

  return $info;
}

/**
 * Implements hook_views_api().
 */
function prc_workflow_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'prc_workflow') . '/includes/views',
  );
}

/**
 * Implements hook_token_info()
 *
 * @return array
 */
function prc_workflow_token_info(){
  $node['workflow-comments'] = array(
    'name' => t('Workflow Comments'),
    'description' => t('Comments associated with changes in the revision state.')
  );

  $type = array(
    'name' => t('Message'),
    'description' => t('Tokens related to individual messages.'),
    'needs-data' => 'message',
  );
  return array(
    'types' => array('message' => $type),
    'tokens' => array('message' => $node),
  );
}

/**
 * Implements hook_tokens()
 * @param $type
 * @param $tokens
 * @param array $data
 * @param array $options
 * @return array
 */
function prc_workflow_tokens($type, $tokens, $data = array(), $options = array()){
  $replacements = array();
  if($type == 'message' && !empty($data['message'])){
    foreach ($tokens as $name => $original) {
      $message = $data['message'];
      $m = entity_metadata_wrapper('message', $message);
      switch($name){
        case 'field-node:workflow-comments' :
          //Fetch the latest comment for this node revision from the db
          $node = $m->field_node->value();
          $vid = $m->field_version_id->value();

          $result = db_query('select * from node_revision_states_history where vid = :vid and nid = :nid order by "timestamp" DESC;',
            array(':vid' => $vid, ':nid' => $node->nid)
          );
          $history = $result->fetchAll();
          $latest = array_shift($history);
          if(!empty($latest)) {
            $replacements[$original] = check_plain($latest->log);
          }
          break;
      }
    }
  }
  return $replacements;
}


/**
 * Implements hook_state_flow_machine_type_alter()
 *
 * @param string $machine_type
 * @param object $node
 */
function prc_workflow_state_flow_machine_type_alter(&$machine_type, $node) {
  if($node->type === 'digital_library_content'){
    $machine_type = 'prc_workflow';
  }
}

/**
 * Implements HOOK_form_FORM_ID_alter()
 */
function prc_workflow_form_digital_library_content_node_form_alter(&$form, &$form_state){
  $node = $form['#node'];

  //state flow won't work without a vid, so skip on node creation
  if(!empty($node->vid)) {
    //Add action buttons for workflow events
    $state_flow = state_flow_load_state_machine($node);

    $action_button = array(
      '#type' => 'submit',
      '#access' => TRUE,
      '#submit' => array('node_form_submit', 'prc_workflow_submit_handler'),
    );

    //Find the event appropriate to the state
    $weight = -10;

    foreach ($state_flow->get_available_events() as $key => $event) {
      //make sure only actions available to the user are displayed
      if($event->validate()) {
        //use our button prototype from above and customize for the context
        $options = $event->get_options();
        $form['actions'][$key] = $action_button;
        $form['actions'][$key]['#value'] = $options['label'];
        $form['actions'][$key]['#weight'] = $weight;

        $weight += -3;
      }
    }

    //Change the text of the submit button to save draft
    $form['actions']['submit']['#value'] = "Save Draft";
  }
}

/**
 * Implements hook_form_FORM_ID_alter()
 * @param $form
 * @param $form_state
 */
function prc_workflow_form_state_flow_events_revision_alter(&$form, &$form_state){
  $form['#submit'][] = 'prc_workflow_events_submit';
  if($form['event']['#value'] == 'denied'){
    $form['event_comment']['#title'] = t('Changes before Approval');
    $form['event_comment']['#description'] = t('Instructions: (to be added)');
  }
}

/**
 * Additional submit handler for revisions.
 *
 * @param $form
 * @param $form_state
 */
function prc_workflow_events_submit(&$form, &$form_state){
  //Redirect to our content tab instead of the workflow pages
  $form_state['redirect'] = 'admin-content';
}

/**
 * Handles submission of the form by workflow actions
 *
 * @param $form
 * @param $form_state
 */
function prc_workflow_submit_handler($form, &$form_state){
  $node = $form['#node'];

  //Determine which button was pressed and fire the corresponding event
  if(!empty($node->vid)) {//skip if we are creating a new node

    //node submit fires before this and creates a new revision
    //Retrieve that most recently saved vid
    $latest_vid = db_query('
    SELECT nr.vid
    FROM {node_revision} nr
    WHERE nr.nid = :nid
    ORDER BY nr.vid DESC
    LIMIT 0, 1',
      array(':nid' => $node->nid))->fetchField();

    //we create a new revision for each state change, but preserve the current state
    $state_flow_previous = state_flow_load_state_machine($node);
    $node->vid = $latest_vid;
    $state_flow =  state_flow_load_state_machine($node);
    $state_flow->force_state($state_flow_previous->get_current_state());

    $clicked = $form_state['clicked_button']['#value'];
    foreach ($state_flow->get_available_events() as $key => $event) {
      $options = $event->get_options();
      if ($clicked == $options['label']) {
        //redirect to the confirmation form
        unset($_GET['destination']);
        $form_state['redirect'] = 'node/' . $node->nid . '/revisions/' . $latest_vid . '/workflow/' . $key;
      }
    }
  }
}

/**
 * A state machine guard callback to determine whether the user taking the action
 * is the owner of the corresponding node.
 *
 * @param $event
 */
function prc_workflow_user_owns_node($event, $node = NULL, $account = NULL){
  if(!$node) {
    $machine = $event->get_machine();

    $node = $machine->get_object();
  }

  if(!$account) {
    global $user;
    $account = $user;
  }

  if($node->uid === $account->uid){
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_state_flow_event_fired()
 *
 * @param $node
 * @param $event_key
 * @param $uid
 * @param $log
 */
function prc_workflow_state_flow_event_fired($node, $event_key, $uid, $log){
  $machine = state_flow_load_state_machine($node);
  switch($event_key){
    case 'approval_requested':
      prc_workflow_message('ready_for_review', $node);
      break;
    case 'rescind_request':
      prc_workflow_message('rescind_request', $node);
      break;
    case 'denied':
      prc_workflow_message('request_changes', $node);
      break;
    case 'approved' :
      prc_workflow_message('published_notice', $node);
      break;
    case 'unpublish':
      prc_workflow_message('unpublished_notice', $node);
      //We are firing this here because exiting doesn't necessarily mean unpublish
      $machine->on_exit_published();
      break;
    case 'update_published' :

      //$machine->on_enter_published();
  }
}

/**
 * Helper function to create messages
 *
 * @param $message_type
 * @param $node
 */
function prc_workflow_message($message_type, $node){
  global $user;

  $message = message_create($message_type);

  $wrapper = entity_metadata_wrapper('message', $message);

  $wrapper->field_node->set($node);

  if($message_type == 'request_changes') {
    $wrapper->field_version_id->set($node->vid);
  }

  $wrapper->field_user_ref->set($user);

  $wrapper->save();

  // This message type is associated with roles in prc_emails.
  _prc_emails_message_create($message, $node);
}

/**
 * Get information on all available states
 *
 * @return array
 */
function prc_workflow_get_all_states(){
  //mock a node object in order to load a machine
  $node = new stdClass();
  $node->vid = 1;
  $node->type = 'digital_library_content';
  $machine = state_flow_load_state_machine($node);

  return $machine->get_states_options();
}
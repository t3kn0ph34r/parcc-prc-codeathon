<?php

/**
 * @file Hooks and configuration pertaining to the editing workflow of the PRC site.
 */

/**
 * Implements hook_permission
 *
 * @return array
 */
function prc_workflow_permission() {
  return array(
    'request approval of prc content' => array(
      'title' => t('Request Approval of PRC content'),
      'description' => t('Request that content be approved and published through the PRC workflow.'),
    ),
    'approve prc content' => array(
      'title' => t('Publish PRC content'),
      'description' => t('Approve and publish content managed through the PRC workflow.'),
    ),
    'deny prc content' => array(
      'title' => t('Deny PRC content'),
      'description' => t('Deny publishing of content managed through the PRC workflow.')
    ),
    'unpublish prc content' => array(
      'title' => t('Unpublish PRC content'),
      'description' => t('Move content managed through the PRC workflow from published back to draft'),
    ),
  );
}


/**
 * Implements hook_menu_alter()
 */
function prc_workflow_menu_alter(&$menu) {
  $menu['node/%node/edit']['access callback'] = 'prc_workflow_access';
  $menu['node/%node/revisions/%/workflow']['access callback'] = 'prc_workflow_events_revision_access';
  $menu['node/%node/revisions/%/edit']['access callback'] = 'prc_workflow_access';
}

function prc_workflow_access($op, $node) {
  if (node_access($op, $node)) {

    //Block access to editing for contributors when under review
    if ($op == 'update' && prc_workflow_reported_state($node->nid) === 'ready_for_review') {

      return user_access('approve prc content');
    }else {
      return TRUE;
    }
  }
  else {
    return FALSE;
  }
}

/**
 * Menu access callback for the node revision workflow transition page.
 */
function prc_workflow_events_revision_access($node, $event_name = NULL) {
  $machine = state_flow_load_state_machine($node);

  //if there is an event name base access on that, otherwise pass to state flow
  if ($event_name) {
    $event = $machine->get_event($event_name);

    return $event->validate();
  }
  else {
    return !empty($event_name) ? state_flow_access($node, $event_name) : state_flow_menu_node_access($node);
  }
}

/**
 * Implements hook_ctools_plugin_directory()
 *
 * @param $owner
 * @param $plugin_type
 * @return string
 */
function prc_workflow_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'ctools') {
    return "plugins/$plugin_type";
  }
}

/**
 * Implements hook_state_flow_plugins()
 */
function prc_workflow_state_flow_plugins() {
  $info = array();

  $info['prc_workflow'] = array(
    'handler' => array(
      'parent' => 'state_flow',
      'class' => 'prcWorkflow',
      'file' => 'prcWorkflow.inc',
      'path' => drupal_get_path('module', 'prc_workflow') . '/plugins',
    )
  );

  return $info;
}

/**
 * Implements hook_views_api().
 */
function prc_workflow_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'prc_workflow') . '/includes/views',
  );
}

/**
 * Implements hook_token_info()
 *
 * @return array
 */
function prc_workflow_token_info() {
  $node['workflow-comments'] = array(
    'name' => t('Workflow Comments'),
    'description' => t('Comments associated with changes in the revision state.')
  );

  $type = array(
    'name' => t('Message'),
    'description' => t('Tokens related to individual messages.'),
    'needs-data' => 'message',
  );
  return array(
    'types' => array('message' => $type),
    'tokens' => array('message' => $node),
  );
}

/**
 * Implements hook_tokens()
 * @param $type
 * @param $tokens
 * @param array $data
 * @param array $options
 * @return array
 */
function prc_workflow_tokens($type, $tokens, $data = array(), $options = array()) {
  $replacements = array();
  if ($type == 'message' && !empty($data['message'])) {
    foreach ($tokens as $name => $original) {
      $message = $data['message'];
      $m = entity_metadata_wrapper('message', $message);
      switch ($name) {
        case 'field-node:workflow-comments' :
          //Fetch the latest comment for this node revision from the db
          $node = $m->field_node->value();
          $vid = $m->field_version_id->value();

          $result = db_query('select * from {node_revision_states_history} where vid = :vid and nid = :nid order by "timestamp" DESC;',
            array(':vid' => $vid, ':nid' => $node->nid)
          );
          $history = $result->fetchAll();
          $latest = array_shift($history);
          if (!empty($latest)) {
            $replacements[$original] = check_plain($latest->log);
          }
          break;
      }
    }
  }
  return $replacements;
}


/**
 * Implements hook_state_flow_machine_type_alter()
 *
 * @param string $machine_type
 * @param object $node
 */
function prc_workflow_state_flow_machine_type_alter(&$machine_type, $node) {
  if ($node->type === 'digital_library_content') {
    $machine_type = 'prc_workflow';
  }
}

/**
 * Implements HOOK_form_FORM_ID_alter()
 */
function prc_workflow_form_digital_library_content_node_form_alter(&$form, &$form_state) {
  $node = $form['#node'];

  //state flow won't work without a vid, so skip on node creation
  if (!empty($node->vid)) {
    //Add action buttons for workflow events
    $state_flow = state_flow_load_state_machine($node);

    $action_button = array(
      '#type' => 'submit',
      '#access' => TRUE,
      '#submit' => array(
        'prc_workflow_pre_submit_handler',
        'node_form_submit',
        'prc_workflow_submit_handler'
      ),
    );

    //Find the event appropriate to the state
    $weight = -10;

    $events = $state_flow->get_available_events();

    foreach ($events as $key => $event) {
      //make sure only actions available to the user are displayed
      if ($event->validate()) {
        //use our button prototype from above and customize for the context
        $options = $event->get_options();
        $form['actions'][$key] = $action_button;
        $form['actions'][$key]['#value'] = $options['label'];
        $form['actions'][$key]['#weight'] = $weight;

        $weight += -3;
      }
    }

    //Change the text of the submit button to save draft
    $form['actions']['submit']['#value'] = "Save Draft";
  }
}

/**
 * Implements hook_form_FORM_ID_alter()
 * @param $form
 * @param $form_state
 */
function prc_workflow_form_state_flow_events_revision_alter(&$form, &$form_state) {
  $form['#submit'][] = 'prc_workflow_events_submit';
  if ($form['event']['#value'] == 'denied') {
    $form['event_comment']['#title'] = t('Changes before Approval');
    $form['event_comment']['#description'] = t('Instructions: (to be added)');
  }
}

/**
 * Additional submit handler for revisions.
 *
 * @param $form
 * @param $form_state
 */
function prc_workflow_events_submit(&$form, &$form_state) {
  //Redirect to our content tab instead of the workflow pages
  $form_state['redirect'] = 'admin-content';
}

/**
 *
 */
function prc_workflow_pre_submit_handler($form, &$form_state) {
  // This empty pre-submit handler needs to be here
  // in order for State Machine to work.
  // Taking it out breaks it!
}


/**
 * Handles submission of the form by workflow actions
 *
 * @param $form
 * @param $form_state
 */
function prc_workflow_submit_handler($form, &$form_state) {

  $node = $form['#node'];

  //Determine which button was pressed and fire the corresponding event
  if (!empty($node->vid)) {//skip if we are creating a new node

    $clicked = $form_state['clicked_button']['#value'];
    $state_machine = state_flow_load_state_machine($node, TRUE);
    $events = $state_machine->get_all_events();

    foreach ($events as $key => $event) {
      $option_label = $event['label'];
      if ($clicked == $option_label) {

        //Workaround having to do with this being action buttons on edit form
        if(isset($event['actual_event'])){
          $key = $event['actual_event'];
          $event = $events[$event['actual_event']];
        }

        //Get the correct version of the node
        $state_to_fetch = $event['origin'];

        $node = prc_workflow_fetch_latest_node_version_by_state($node->nid, $state_to_fetch);

        //redirect to the confirmation form
        unset($_GET['destination']);
        $form_state['redirect'] = 'node/' . $node->nid . '/revisions/' . $node->vid . '/workflow/' . $key;
        continue;
      }
    }
  }
}

/**
 * Fetches the most recent node revision of a particular state
 *
 * @param $nid
 * @param $state
 * @return bool|mixed
 */
function prc_workflow_fetch_latest_node_version_by_state($nid, $state) {

  $vid = db_query("
    select nrsh.vid from {node_revision_states_history} nrsh
    where nrsh.nid = :nid
      and nrsh.state = :state
    order by nrsh.nrshid DESC limit 1",
    array(':nid' => $nid, ':state' => $state))->fetchField();

  return node_load($nid, $vid, TRUE);
}

/**
 * A state machine guard callback to determine whether the user taking the action
 * is the owner of the corresponding node.
 *
 * @param $event
 */
function prc_workflow_user_owns_node($event, $node = NULL, $account = NULL) {
  if (!$node) {
    $machine = $event->get_machine();

    $node = $machine->get_object();
  }

  if (!$account) {
    global $user;
    $account = $user;
  }

  if ($node->uid === $account->uid) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_state_flow_event_fired()
 *
 * @param $node
 * @param $event_key
 * @param $uid
 * @param $log
 */
function prc_workflow_state_flow_event_fired($node, $event_key, $uid, $log) {
  $machine = state_flow_load_state_machine($node);

  switch ($event_key) {
    case 'approval_requested':
      prc_workflow_message('ready_for_review', $node);
      break;
    case 'rescind_request':
      prc_workflow_message('rescind_review_request', $node);
      break;
    case 'denied':
      prc_workflow_message('request_changes', $node);
      break;
    case 'approved' :
      prc_workflow_message('published_notice', $node);
      break;
    case 'unpublish':
      prc_workflow_message('unpublished_notice', $node);
      //We are firing this here because exiting doesn't necessarily mean unpublish
      $machine->on_exit_published();
      break;
    case 'update_published' :
      prc_workflow_message('published_notice', $node);
      break;
  }

}

/**
 * Helper function to create messages
 *
 * @param $message_type
 * @param $node
 */
function prc_workflow_message($message_type, $node) {
  global $user;

  $message = message_create($message_type);

  $wrapper = entity_metadata_wrapper('message', $message);

  $wrapper->field_node->set($node);

  if ($message_type == 'request_changes') {
    $wrapper->field_version_id->set($node->vid);
  }

  $wrapper->field_user_ref->set($user);

  $wrapper->save();

  // This message type is associated with roles in prc_emails.
  _prc_emails_message_create($message, $node);
}

/**
 * Base status on the status of all active revisions rather than just the most
 * recent draft.
 *
 * @param $node
 */
function prc_workflow_reported_state($nid){
  //get the active drafts
  $drafts = db_query("
    select * from {node_revision_states} nrs
    where nrs.nid = :nid
      and nrs.status = 1",
    array(':nid' => $nid))->fetchAllAssoc('vid');

  $reported_state = 'draft';
  foreach($drafts as $draft){
    if($draft->state == 'ready_for_review'){
      $reported_state = 'ready_for_review';
      break;
    }elseif($draft->state == 'published'){
      $reported_state = 'published';
    }
  }
  //If the node was ever published, but is currently draft, report the state as unpublished
  if($reported_state == 'draft'){
    $published_history = db_query("select state from {node_revision_states_history} where nid = :nid and state = 'published'", array(':nid' => $nid))->fetchField();
    if(count($published_history)){
      $reported_state = 'unpublished';
    }
  }

  return $reported_state;
}
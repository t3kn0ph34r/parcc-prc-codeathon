<?php

/**
 * @file Hooks and configuration pertaining to the editing workflow of the PRC site.
 */

//@todo menu alter to block editing of nodes or revisions that are "published"

/**
 * Implements hook_permission
 *
 * @return array
 */
function prc_workflow_permission(){
  return array(
    'request approval of prc content' => array(
      'title' => t('Request Approval of PRC content'),
      'description' => t('Request that content be approved and published through the PRC workflow.'),
    ),
    'approve prc content' => array(
      'title' => t('Publish PRC content'),
      'description' => t('Approve and publish content managed through the PRC workflow.'),
    ),
    'deny prc content' => array(
      'title' => t('Deny PRC content'),
      'description' => t('Deny publishing of content managed through the PRC workflow.')
    ),
    'unpublish prc content' => array(
      'title' => t('Unpublish PRC content'),
      'description' => t('Move content managed through the PRC workflow from published back to draft'),
    ),
  );
}


/**
 * Implements hook_menu_alter()
 */
function prc_workflow_menu_alter(&$menu){
  $menu['node/%node/edit']['access callback'] = 'prc_workflow_access';
}

function prc_workflow_access($op, $node){
  if(node_access($op, $node)){
    $state_flow = state_flow_load_state_machine($node);

    //@todo: Exception for user 1?
    //@todo: How does somebody cancel their review request?
    if($state_flow->get_current_state() === 'ready_for_review') {
      return user_access('approve prc content');
    }else{
      return TRUE;
    }
  }else {
    return FALSE;
  }
}

/**
 * Implements hook_ctools_plugin_directory()
 *
 * @param $owner
 * @param $plugin_type
 * @return string
 */
function prc_workflow_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'ctools') {
    return "plugins/$plugin_type";
  }
}

/**
 * Implements hook_state_flow_plugins()
 */
function prc_workflow_state_flow_plugins(){
  $info = array();

  $info['prc_workflow'] = array(
    'handler' => array(
      'parent' => 'state_flow',
      'class' => 'prcWorkflow',
      'file' => 'prcWorkflow.inc',
      'path' => drupal_get_path('module', 'prc_workflow').'/plugins',
    )
  );

  return $info;
}

/**
 * Implements hook_state_flow_machine_type_alter()
 *
 * @param string $machine_type
 * @param object $node
 */
function prc_workflow_state_flow_machine_type_alter(&$machine_type, $node) {
  $machine_type = '';
  if($node->type === 'digital_library_content'){
    $machine_type = 'prc_workflow';
  }
}

/**
 * Implements HOOK_form_FORM_ID_alter()
 */
function prc_workflow_form_digital_library_content_node_form_alter(&$form, &$form_state){
  $node = $form['#node'];

  //state flow won't work without a vid, so skip on node creation
  if(!empty($node->vid)) {
    //Add action buttons for workflow events
    $state_flow = state_flow_load_state_machine($node);

    $action_button = array(
      '#type' => 'submit',
      '#access' => TRUE,
      '#submit' => array('prc_workflow_submit_handler'),
    );

    $label = $state_flow->get_label_for_current_state();

    //@todo: $label needs to be printed somewhere on the page to indicate the current state

    //Find the event appropriate to the state
    $weight = -10;

    foreach ($state_flow->get_available_events() as $key => $event) {
      //make sure only actions available to the user are displayed
      if($event->validate()) {
        //use our button prototype from above and customize for the context
        $options = $event->get_options();
        $form['actions'][$key] = $action_button;
        $form['actions'][$key]['#value'] = $options['label'];
        $form['actions'][$key]['#weight'] = $weight;

        $weight += -3; //@todo: if this doesn't work we can add a weight attribute to the events options
      }
    }

    //Change the text of the submit button to save draft, except when editing the published draft
    //@todo: detect whether we are working on the published revision as a curator
    if(true) {
      $form['actions']['submit']['#value'] = "Save Draft";
    }
  }
}

/**
 * Handles submission of the form by workflow actions
 *
 * @param $form
 * @param $form_state
 */
function prc_workflow_submit_handler($form, &$form_state){

  //@todo: does this create a new revision even if nothing has changed besides the state?  Is that appropriate?
  node_form_submit($form, $form_state);
  $node = $form['#node'];

  //Determine which button was pressed and fire the corresponding event
  if(!empty($node->vid)) {//skip if we are creating a new node

    //@todo: make sure this is still correct if we are editing a draft vs. the published revision
    $latest_vid = db_query('
    SELECT nr.vid
    FROM {node_revision} nr
    WHERE nr.nid = :nid
    ORDER BY nr.vid DESC
    LIMIT 0, 1',
      array(':nid' => $node->nid))->fetchField();


    $state_flow = state_flow_load_state_machine($node);
    $clicked = $form_state['clicked_button']['#value'];
    foreach ($state_flow->get_available_events() as $key => $event) {
      $options = $event->get_options();
      if ($clicked == $options['label']) {
        //redirect to the confirmation form
        unset($_GET['destination']);
        $form_state['redirect'] = 'node/' . $node->nid . '/revisions/' . $latest_vid . '/workflow/' . $key;
      }
    }
  }
}

/**
 * Implements hook_form_form_id_form_alter
 *
 * @param $form
 * @param $form_state
 */
function prc_workflow_form_state_flow_events_revision_alter(&$form, &$form_state){
  //Add handler for notifications
  //$form['#submit'][] = 'prc_workflow_notification_submit_handler';
}

/**
 * A state machine guard callback to determine whether the user taking the action
 * is the owner of the corresponding node.
 *
 * @param $event
 */
function prc_workflow_user_owns_node($event){
  $machine = $event->get_machine();
  global $user;

  $node = $machine->get_object();

  if($node->uid === $user->uid){
    return TRUE;
  }
  return FALSE;
}
